---
layout: post
author: meshchenko
---
**Memory**, **Thread** и **Call Stack** - это три кита, три фундаментальных принципа, на которых основывается весь синхронный Javascript. Для того, чтобы в них разобраться, нужно запустить код и, строчка за строчкой, понять что происходит.

Рассмотрим простой javascript - код.
{% highlight javascript %}
	const num = 3;
	function multiplyBy2 (num) {
		const result = num * 2;
		return result;
	};
	const name = "John";
{% endhighlight %}

Как же выполняется код?
Если вкратце, то javascript будет выполняться сверху вниз, последовательно, по пути создавая переменные и записывая в них значения.

Если рассматривать более подробно, то как только мы запускаем наш код, то создается **Global Execution Context**, или глобальный контекст выполнения. Это среда, в которой находится вся наша программа и выше которой у нас доступа нет.
Внутри глобального контекста у нас есть **Global Thread** и **Global Memory**.

![Global execution context](/assets/img/2019-06-13-под-капотом-js-(Memory,-Thread,-Call-Stack)/1.jpg)

После выполнения первой строчки, мы создаем в Global memory переменную **num** и записываем в нее значение **3**.  
Во второй строчке у нас функция, но она не вызывается, потому просто создаем переменную **multiplyBy2** и записываем в нее текст нашей функции, не заходя в нее.  
В последней строчке создается переменная **name** и записываем в нее значение **"John"**.

![Global execution context](/assets/img/2019-06-13-под-капотом-js-(Memory,-Thread,-Call-Stack)/2.jpg)

На этом выполнение программы заканчивается.

Но что же будет, если мы не просто опишем функцию, но и вызовем ее?
{% highlight javascript %}
	const num = 3;
	function multiplyBy2 (num) {
		const result = num * 2;
		return result;
	};
	const output = multiplyBy2(2);
{% endhighlight %}

Как будет происходить выполнение последней строчки?  
1) Сначала в глобальной области видимости появится переменная **output** и ей присвоится значение **undefined**  
2) Затем создается новая область видимости - **Local Execution Context**. В ней есть свои **Local memory** и **Local Thread**.  
3) В **Local Thread** из глобальной памяти копируется код функции, по которому будет идти выполнение  
4) В **local memory** создаем переменную **num**, ей присваиваем значение **2**  
5) Создаем переменную **result**, присваиваем значение **4**  
6) возвращаем значение **4** в глобальную память  
7) удаляем локальный контекст  

![Global execution context](/assets/img/2019-06-13-под-капотом-js-(Memory,-Thread,-Call-Stack)/3.jpg)

**Важно!** Глобальный контекст - один, локальных - на протяжении работы программы может быть много.

Итак, подходим к понятию **Call Stack**.
Как мы уже поняли, execution thread изначально находится в глобальном контексте, потом при вызове функции создается новый локальный контекст.  Если внутри функции будет вызываться еще одна функция, то создастся локальный контекст внутри нашего локального контекста. И так до бесконечности.
Но как понять, в чьем контексте мы находимся?  
![Global execution context](/assets/img/2019-06-13-под-капотом-js-(Memory,-Thread,-Call-Stack)/4.jpg)
**Call Stack** - это специальная структура, которая позволяет отследить, где конкретно находится thread of execution в данный момент.  
В самом низу стека всегда находится **global()** - это значит что сейчас мы находимся в глобальном контексте
Если мы зайдем в функцию **multiplyBy2()**, то в стек сверху добавится запись об этом.  
Если внутри функции вызовем еще одну функцию **somefun()**, то в стек сверху добавится еще одна запись. 
![Global execution context](/assets/img/2019-06-13-под-капотом-js-(Memory,-Thread,-Call-Stack)/5.jpg)
Удаляться же элементы будут в обратном порядке. Сначала **somefun()**, потом **multiplyBy2()** и в итоге мы оказываемся снова в **Глобальном Контексте**.  
Это позволяет механизму javascript никогда не волноваться о том, в каком контексте сейчас находимся. Что наверху **Call Stack** - там и мы.

## Резюме
1) **Memory** - место, где хранятся наши переменные  
2) **Thread** - место, где шаг за шагом выполняется наш код  
3) **Call Stack** - структура данных, позволяющая понять, в каком конкретно Execution Context мы сейчас находимся.  

**Важно понимать**, что эти принципы нужно знать не для теоретических целей или интеллектуального люботытства, а потому что мы работаем с ними каждый день. И понимание этих вещей делает написание чистого кода и последующий дебаггинг лучше.