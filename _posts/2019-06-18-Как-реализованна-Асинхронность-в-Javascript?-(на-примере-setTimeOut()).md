---
layout: post
author: meshchenko
---
JavaScript - это однопоточный синхронный язык. Это означает что все команды в нем выполняются в порядке общей очереди и если где-то в коде возникает затор, то выполнение кода остановится.
Рассмотрим как реализована **асинхронность** на примере setTimeout(), при котором функция выпадает из общего потока и выполняется через заданное время.

Секрет прост - асинхронность реализовывается не джаваскриптом, а сторонними средствами - окружением. 
И этим сторонним средством является **Web Browser API ( он же Web Browser features**. 

т.е. когда js видит команду setTimeOut(printHello, 100), он отсылает ее в Web Browser features (API), который сам отсчитывает нужное время и возвращает функцию обратно.  
Как же Web Browser Features определяет, когда ему выводить в call stack то, что вернул setTimeOut?

Есть два правила выполнения отложенного асинхронного кода в javascript.  
1) Вносить отложенную функцию в queue (the Callback queue), когда время задержки закончится (Complete: done)
2) Добавлять функцию в Call Stack (т.е выполнять ее) **ТОЛЬКО** когда Call Stack полностью пуст. (Эту проверку проводит Event Loop)

Всё. Вывод - асинхронные операции делает не js, а его окружение - браузер (Chrome, Mozila, Safari - не важно).

##Что такое Callback queue?##  
Это просто очередь из элементов, готовых к выполнению и ожидающих пока Call Stack опустеет (т.е. синхронная часть программы завершит свое выполнение)

##Что такое Event Loop?##  
Event Loop - Это всего лишь название механизма, постоянно проверяющего, есть ли в Callback query элементы, и если находит, то начинает проверять пуст ли Call Stack.  
Как только оказывается что стек вызовов пуст, это означает что программа завершила выполнение всего синхронного кода. В этот момент начинают по очереди выполняться функции из callback query.

Вывод: все асинхронные операции будут выполнены ТОЛЬКО после выполнения всего основного синхронного кода. Т.е команда {% highlight javascript %}setTimeOut(printHello, 0);{% endhighlight %} будет выполнена в самом конце программы, даже несмотря на то что она должна была выполниться мгновенно (по крайней мере так кажется на первый взгляд).

Вот и всё! Асинхронность в javascript - это не сложно.
